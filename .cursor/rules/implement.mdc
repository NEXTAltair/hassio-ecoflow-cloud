---
description: Always attach when Implementing Code (Act/Code MODE)
globs:
alwaysApply: false
---
---
description: Include these rules while IMPLEMENTATION/Coding.
globs:
alwaysApply: true
---
コードの実装や変更の前に**必ず**2つのことを行うこと:
a. `docs/` と `tasks/` 内のドキュメントを読み理解する。
a. `custom_components/` など他のコードから必要なコードコンテキストを取得する。
---
# 実装 (ACTモード/Codeモード):
<PROGRAMMING PRINCIPLES>
- algorithm_efficiency(アルゴリズム効率): 最も効率的なアルゴリズムとデータ構造を使用する。
- modularity(モジュール化): 複雑なロジックは小さな単位に分割する。可能ならクラス、ファイル、ディレクトリ、モジュール、関数などへ分ける。
- file_management(ファイル管理): 長大なファイルは、より小さく管理しやすいファイルに分割する。
- import_statements(インポート方針): 直接ファイルを修正するのではなく、他ファイルから関数をインポートして使用する。
- file_organization(ファイル整理): ファイルをディレクトリ･フォルダ単位で整理する。
- reuse(再利用): 既存コードを優先的に再利用し、新たに書くのは最小限にする。
- code_preservation(動作コードの保護): 正常動作しているコンポーネントは必要がなければ変更しない。
- systematic_sequence(系統的手順): 1ステップを完全に終わらせてから次に進む。
- design_patterns(設計パターン): 将来変更や拡張しやすい柔軟かつ保守性の高いコード設計を行う。
- proactive_testing(積極的テスト): すべての機能コードには必ず適切なテストコードを併設する。
</PROGRAMMING PRINCIPLES>

<SYSTEMATIC CODE PROTOCOL>
[ステップ1]
<ANALYZE CODE>
<DEPENDENCY ANALYSIS>
- どのコンポーネントが影響を受けるか?
- どんな依存関係が存在するか?
- 影響はローカルか、コアロジックに及ぶか?
- どの機能がどう影響を受けるか?
- この変更による波及効果は?
</DEPENDENCY ANALYSIS>
<FLOW ANALYSIS>
- 変更提案前に、関連ユースケースを**エントリーポイント(関数呼び出し、変数初期化など)からすべての影響範囲まで**完全に分析する。
- データとロジックの流れをすべて追跡して、全体像を理解する。
</FLOW ANALYSIS>
- @memory.mdcに記載されたファイルにおける依存関係や使用状況も正確に記録する。
</ANALYZE CODE>

[ステップ2]
<PLAN CODE>
- 必要であれば<CLARIFICATION>プロセスを開始する。
- <STEP BY STEP REASONING>を使って詳細計画を立てる(コンポーネント依存、アーキテクチャ考慮)。
- <REASONING PRESENTATION>で、コード変更の目的、各変更箇所、他への影響を説明する。
<STRUCTURED PROPOSALS>
- 以下を明確に示す提案を作成する:
  1) 変更対象のファイル、関数、コード行
  2) 変更理由(バグ修正、改善、新機能)
  3) 直接影響を受けるモジュール･ファイル
  4) 副作用の可能性
  5) トレードオフの詳細な説明
</STRUCTURED PROPOSALS>
</PLAN CODE>

[ステップ3]
<MAKE CHANGES>

1. @memory.mdcに従い、現在の状態を記録する。
- どこが正常動作しているか
- 現在のエラー/問題点
- 影響を受けるファイル

2. 単一の論理的変更ごとに計画する。
<INCREMENTAL ROLLOUTS>
- 一度に1つの論理的機能だけ変更する。
- 関連コードすべてに適切な調整を加える。
- 依存関係や派生する問題も全て解決する。
- architecture_preservation(アーキテクチャ維持): 既存構造に沿ってコードを統合する。既存ファイル構成を壊さない。
</INCREMENTAL ROLLOUTS>

3. シミュレーションテストを実施。
<SIMULATION ANALYSIS>
- ユーザー操作や挙動をシミュレートし、変更が想定通り動作するか、すべての影響範囲を確認する。
</SIMULATION ANALYSIS>
<SIMULATION VALIDATION>
- シミュレーションが通らなければ、修正を加えてから次に進む。
- シミュレーション合格後に実装を開始する。
</SIMULATION VALIDATION>
</MAKE CHANGES>

[ステップ4] <TESTING>を実行。

[ステップ5] 1~4を繰り返してすべての変更を実施。
- すべて系統立てて変更。
- 1つずつ検証･テスト。

[ステップ6] 実装後に最適化。
- テスト･検証後にコードを最適化する。

</SYSTEMATIC CODE PROTOCOL>

<REFERENCE>
- 関連ドキュメントやベストプラクティスを参照する。
- 必要なら<WEB USE>を使って調査する。
</REFERENCE>

# コーディングルール詳細 (AI向け指示)

## 開発環境
- **OS:** Windows 11 を開発環境として想定する。
- **Python:** Python 3.12 を使用する。
- **依存関係管理:** 開発環境の依存関係管理には `uv` を使用する。
- **設定:** 特別な理由がない限り pytest や Ruff の設定は `pyproject.toml` に一任する

## コーディングスタイル
- **PEP 8:** PEP 8 ガイドラインに従うこと。
- **命名規則:**
    - 変数名、関数名、メソッド名は、その役割や意味が明確にわかる具体的な名前 (`snake_case`) を使用する。
    - クラス名は、その役割や特性を具体的に表す名詞または名詞句 (`CamelCase`) とする。**安易に動詞に `er` を付けただけの名前(例: `Loader`, `Runner`)は避け、より具体的な名前(例: `DeviceManager`, `MQTTClient`)を選ぶこと。**
- **パス処理:** パス操作には `os` モジュールではなく `pathlib` モジュールを使用する。
- **リスト内包表記:** 可読性を維持するため、リスト内包表記内での `if` と `for` の使用はそれぞれ1つまでに制限する。

## 型ヒントと静的解析
- **型ヒント:**
    - すべての関数、メソッドの引数と戻り値には、可能な限り具体的な型ヒントを付与する。
    - **モダンな型:** `typing.List` や `typing.Dict` ではなく、Python 3.9 以降の組み込み型 (`list`, `dict`) や `collections.abc` の型を使用する。Optional型も使用せず `str | None`と表記する。
    - **複雑な型:** 複雑な辞書構造には `TypedDict` を活用する。
    - **オーバライド:** 親メソッドをオーバーライドしたメソッドは `@override`デコレーターを使用しオーバーライドしてあると明示する。
    - **メソッドチェーン:** メソッドチェーンを考慮する場合は `Self` 型を使用する。
    - **`Any` の回避:** `Any` 型の使用は最小限に留め、具体的な型を指定するよう努めること。やむを得ず使用する場合は理由をコメントに残すこと。
- **静的解析:**
    - **エラー抑制禁止:** Mypy や Ruff (lint) が報告するエラーや警告は、`# type: ignore` や `# noqa` コメントで抑制せず、コードや型定義を修正して根本的に解決する。
    - **回避策禁止:** **`try...except ImportError` などで Mypy エラーを回避するような、その場しのぎの対応も禁止する。**

## エラーハンドリング
- **特定のエラー処理:** 予期される特定のエラー(例: `FileNotFoundError`, `ValueError`, `KeyError`, `ConnectionError`)のみを具体的に `try...except` で捕捉し、適切に処理する。
- **過剰なハンドリング回避:** 予期しない一般的な `Exception` を広範囲にキャッチして処理を継続するような、過剰なエラーハンドリングは避けること。不明なエラーはログに記録し、適切に上位に伝播させるか、処理を中断する。
- **無意味なハンドリング回避:** 前段の処理で既にエラーが発生している可能性がある場合、後続の処理で無意味なエラーハンドリング(例: 失敗した可能性のある変数をさらに `try...except` で囲む)を行わないこと。エラー発生時の制御フローを明確に設計する。
- **MQTT/ネットワークエラー:** MQTT接続エラー、ネットワークタイムアウト等は適切にキャッチし、再接続ロジックやユーザーへの通知を含めて処理する。
- **エラーメッセージ:** エラー発生時は、原因特定に役立つ明確なエラーメッセージを含めること。

## 設計原則
- **単一責任の原則 (SRP):** 各クラス、関数、モジュールは、単一の明確な責任を持つように設計する。
- **責任分離:** 状態管理や特定の複雑な処理は、専用のクラスや関数に委譲するを検討する。
- **カプセル化:** クラスの内部実装への依存を避け、公開インターフェースを通じてのみ対話する。

## カプセル化ルール (AI向け指示)
- **最重要禁止事項:**
    - **他クラス内部変数への直接アクセス禁止:** 他クラスの内部変数 (`_` 始まり) には**絶対にアクセスしないこと**。これはカプセル化を破壊し、保守性を著しく低下させる。
- **クラス設計原則:**
    - **Tell, Don't Ask:** クラス利用者は内部状態を知る必要がないように設計すること。状態を問い合わせて外部で判断するのではなく、必要な操作や判断はクラス自身の**振る舞い (メソッド)** として提供すること。
    - **内部状態の非公開:**
        - 内部状態は原則として外部に公開しない。
        - 状態の公開が必要な場合(読み取り専用)は `@property` を使用し、**ミュータブルな内部オブジェクト (`list`, `dict` 等) の参照を直接返さないこと** (防御的コピーも原則禁止)。必要最小限の情報をイミュータブルな形式で返すことを検討すること。
        - 状態変更は、その操作がクラスの責務として意味を持つ公開メソッド経由でのみ行うこと。
    - **ゲッター/セッター原則禁止:** 単純な値取得 (`get_*`) や設定 (`set_*`) のためだけのメソッドは**作成しないこと**。
    - **公開インターフェース最小化:** 外部に公開するメソッドやプロパティは、クラスの責務遂行に**必要最小限**とすること (YAGNI原則)。
    - **命名:** 内部変数は `_` プレフィックスを付与し、公開メンバーは役割が明確な名前とすること。
- **リファクタリング方針:**
    - 既存コードの違反は以下の優先度で修正すること。
        1.  **最高:** 他クラス内部変数への直接アクセス。
        2.  **高:** 他クラス内部メソッド (`_`始まり) への直接アクセス。
        3.  **中:** 安易なゲッター/セッター、ミュータブルな内部参照の返却。
- **チェックリスト (AI向け):**
    - [ ] 他クラス内部変数 (`_`始まり) への直接アクセスはないか?
    - [ ] 内部状態を不必要に公開していないか? (安易なゲッター/セッター、ミュータブル参照返却はないか?)
    - [ ] 公開インターフェースは最小限か?
    - [ ] 命名規則は守られているか?

## 原則違反の通知
- **ユーザーへの通知:** AI がこれらの定義された原則に違反するコードを生成･編集せざるを得ない場合は、**一度作業を停止し、必ずユーザーにその旨と理由を説明し、指示を仰ぐこと。**

## 問題解決プロセス
- **エラー/警告対応:** エラーや警告が発生した場合、AI は以下の手順で対応する。
    1.  **解決策の検討:** 問題の原因を分析し、少なくとも3つ以上の異なる解決策を検討する。
    2.  **最適な解決策の選択:** 検討した解決策の中から、最も適切と考えられるものを選択し、その理由を記録する。
    3.  **試行と反復:** 選択した解決策を適用し、問題が解決したか確認する。解決しない場合は、別の解決策を試すか、さらに別の解決策を検討する。
    4.  **エスカレーション:** 上記の試行を3回以上繰り返しても問題が解決しない場合は、作業を中断し、ユーザーに現在の状況、試した解決策、および考えられる原因を説明し、判断を求めること。

## 自己チェック義務
AI はコードを生成･編集した後、ユーザーに提示する前に**必ず**以下の点について自己チェックを行い、ルール違反があれば修正すること。
- [ ] **半角文字:** コード、コメント、ドキュメント内に全角英数字･全角記号が含まれていないか? (特に括弧、スペース)
- [ ] **モダンな型ヒント:** `typing.List`, `typing.Dict`, `typing.Optional` など古い型を使用していないか? (`list`, `dict`, `| None` を使用しているか?)

# ドキュメンテーションルール (実装時)
- **Docstring:** 各関数･メソッドには Google スタイル docstring **追加すること**。最低限、「Args:」「Returns:」セクション含め、必要応じ「Raises:」セクションも記述すること。
- **モジュールコメント:** 各モジュール冒頭に、そのモジュール目的、主要クラス･関数、外部依存関係等簡潔説明コメント**追加すること**。
- **実装コメント:** 実装意図説明する簡潔明確日本語コメント**記述すること**。
- **コードアノテーション:** コード新規作成または**変更**時、必要応じ Todo Tree 拡張タグ (`TODO`, `FIXME`, `OPTIMIZE` 等) 用いたコメントアノテーション**必ず**追加･更新し、変更意図、将来改善点、修正必要箇所、残課題等明確にすること。使用タグは以下基本とする:
    - `TODO`: 将来実装予定機能･改善点
    - `FIXME`: 修正必要既知問題
    - `OPTIMIZE`: 最適化必要部分
    - `BUG`: 確認済バグ
    - `HACK`: 一時回避策･最適でない実装
    - `XXX`: 特別注意･再考必要箇所
    - `[ ]`: 未完了タスク
    - `[x]`: 完了タスク

# EcoFlow Cloud Home Assistant 実装ルール･設計概要 (AI 向け指示)

## 1. Home Assistantカスタムコンポーネント実装ルール

### 1.1. コンポーネント構造
- **`__init__.py`**: コンポーネントの初期化、設定エントリの管理、プラットフォームのセットアップ
- **`manifest.json`**: コンポーネントのメタデータ、依存関係、バージョン情報
- **`config_flow.py`**: 設定フロー、オプションフロー、ユーザーインターフェース
- **エンティティファイル**: 各エンティティタイプ（sensor, switch, number, select, button）ごとに分離

### 1.2. エンティティ実装ルール
- **継承**: 適切なHome Assistantベースクラスを継承する（`SensorEntity`, `SwitchEntity`等）
- **一意性**: `unique_id`を適切に設定し、エンティティの一意性を保証する
- **状態管理**: エンティティの状態は適切に管理し、不要な更新を避ける
- **属性**: 追加属性は`extra_state_attributes`プロパティで提供する
- **可用性**: `available`プロパティでエンティティの可用性を適切に管理する

### 1.3. MQTT通信ルール
- **非同期処理**: すべてのMQTT操作は非同期で実行する
- **接続管理**: 接続の確立、維持、再接続を適切に管理する
- **エラーハンドリング**: MQTT接続エラー、メッセージ送受信エラーを適切に処理する
- **メッセージ形式**: EcoFlow固有のメッセージ形式に準拠する
- **認証**: 適切な認証情報を使用してMQTTブローカーに接続する

## 2. EcoFlowデバイス管理

### 2.1. デバイス分類
- **内部デバイス** (`devices/internal/`): EcoFlow内部MQTT APIを使用
- **公開デバイス** (`devices/public/`): EcoFlow公開APIを使用
- **Protocol Buffers**: 内部デバイスはProtocol Buffersでデータ交換

### 2.2. デバイス実装パターン
- **ベースクラス継承**: 共通のデバイスベースクラスを継承する
- **データマッピング**: EcoFlowデータをHome Assistantエンティティにマッピング
- **状態同期**: デバイス状態とHome Assistant状態の同期を維持
- **コマンド送信**: デバイス制御コマンドの適切な送信

### 2.3. Protocol Buffers処理
- **`.proto`ファイル管理**: `devices/internal/proto/`で管理
- **Python生成**: `protoc`でPythonファイルを生成
- **バージョン管理**: Protocol Buffersスキーマのバージョン管理
- **エラーハンドリング**: デシリアライゼーションエラーの適切な処理

## 3. 設定とデータ管理

### 3.1. 設定管理
- **設定エントリ**: Home Assistantの設定エントリシステムを使用
- **オプション**: 動的設定変更のためのオプションフロー
- **検証**: 設定値の適切な検証とエラーハンドリング
- **移行**: 設定スキーマの変更時の適切な移行処理

### 3.2. データ保持
- **データホルダー**: `data_holder.py`でデバイスデータを管理
- **状態管理**: デバイス状態の一元管理
- **更新通知**: 状態変更時の適切な通知メカニズム
- **メモリ管理**: 効率的なメモリ使用とガベージコレクション

## 4. 多言語対応

### 4.1. 翻訳ファイル
- **JSON形式**: `translations/`ディレクトリでJSON形式の翻訳ファイル
- **キー統一**: 翻訳キーの一貫性と統一性
- **完全性**: すべての表示文字列の翻訳提供
- **保守性**: 翻訳ファイルの保守しやすい構造

## 5. テストとデバッグ

### 5.1. 診断機能
- **診断データ**: `diagnostics.py`で診断情報を提供
- **サンプルデータ**: `diag/`ディレクトリで診断サンプル
- **デバッグ情報**: 問題解決に役立つ詳細情報
- **プライバシー**: 機密情報の適切な除外

### 5.2. ログ出力
- **適切なレベル**: ログレベルの適切な使用（DEBUG, INFO, WARNING, ERROR）
- **構造化**: 構造化されたログメッセージ
- **コンテキスト**: 問題特定に役立つコンテキスト情報
- **パフォーマンス**: ログ出力のパフォーマンス影響を最小化

# テスト方針

## 基本方針
- 各機能にはテストを作成し、十分なテストカバレッジを確保する。
- Home Assistantのテストフレームワークを活用する。
- 実際のデバイスに依存しないモックテストを実装する。

## テストの種類
- **ユニットテスト**: 個別コンポーネントの機能テスト
- **統合テスト**: コンポーネント間の連携テスト
- **設定テスト**: 設定フローとオプションフローのテスト
- **MQTT テスト**: MQTT通信のモックテスト

## テストの実行
- `pytest` を使用してテストを実行する
- Home Assistantのテストヘルパーを活用する
- CI/CDパイプラインでの自動テスト実行

# テスト (常に実装後にテストを書く) [ACT/Codeモード]
<TESTING>
<DEPENDENCY BASED TESTING>
新しい機能には必ずユニットテストを書く。<ANALYZE CODE>で確認した影響範囲すべてについてテストを実施する。
</DEPENDENCY BASED TESTING>
<NO BREAKAGE ASSERTION>
変更提案後、必ず自分でテストを実行し、パスを確認する。他人任せにせず、コードが壊れていないことを確実にする。
</NO BREAKAGE ASSERTION>
1. テストロジックは実装コードとは別ファイルに書く。クリーンで保守性の高いコードを保つため。
<TEST PLAN>
- 要件や期待される結果に対して、十分網羅的なテスト計画を立てる。
- エッジケースも含めた包括的なテストシナリオを設計する。
- プロジェクトの技術スタックに応じた検証方法を定義する。
- ソリューションの効果を確認するためのモニタリング方法も提案する。
- リグレッション(既存機能の劣化)防止も考慮する。
</TEST PLAN>
2. 重要な新機能には**必ず**テストコードを書く。まず<DEPENDENCY BASED TESTING>と<NO BREAKAGE ASSERTION>で基礎テスト、その後<TEST PLAN>に基づき拡張テストを書く。
3. テスト記録は@memory.mdcに従って整理する。
</TESTING>

- 新機能の実装時には、細部まで徹底して実装･テストを行い、**テスト完了まで決して途中で止めないこと**。

---
コード実装や変更後には**必ず**2つのことを行う:
a. `custom_components/` やその他コード内で影響する可能性のある箇所も更新する。
b. `docs/` と `tasks/` のドキュメントを更新する。

## [API/SDK実装･修正時の厳守事項]

- 必ず公式ドキュメント(バージョン明記されている場合はそれも含む)を精読･参照し、根拠のない推測やハルシネーションに基づいた実装を禁止する。
- **参照した公式ドキュメントのURL、参照日時、可能であればSDKやAPIのバージョン情報は、コメントとしてコード内に残すか、`docs/technical.md` 等の関連ドキュメントに必ず記録すること。**
- 必要に応じてWeb検索･MCP検索(Perplexity等)を活用し、最新仕様･注意点･コミュニティによる知見を調査し、それらの情報源も記録する。
- 参照した根拠、下した設計判断、発見された注意点は、コードコメントや関連ドキュメントに必ず明瞭に記録する。
- これらの事項を怠った場合、実装されたコードはレビューで差し戻し、またはロールバックの対象となることを理解する。

## [Home Assistant特有の実装事項]

- **Home Assistant Core API**: 公式のHome Assistant Core APIドキュメントを参照し、適切なAPIを使用する
- **エンティティレジストリ**: エンティティの登録と管理を適切に行う
- **状態マシン**: Home Assistantの状態マシンを理解し、適切な状態遷移を実装する
- **イベントシステム**: Home Assistantのイベントシステムを活用した通知と連携
- **サービス**: カスタムサービスの実装と登録
- **HACS対応**: HACSでの配布に適した構造とメタデータの提供
