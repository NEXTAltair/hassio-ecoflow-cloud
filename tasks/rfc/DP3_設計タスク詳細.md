# DP3 設計タスク詳細

## 1. Delta Pro 3用デバイス定義設計

*   **目的:** Home AssistantでDelta Pro 3を操作・監視するために必要なエンティティ（センサー、スイッチ、数値入力、セレクト）を定義する。
*   **サブタスク:**
    *   [ ] **現状のEcoFlowデバイス（PowerStream等）で定義されているエンティティの調査:**
        *   既存の `sensor.py`, `switch.py`, `number.py`, `select.py` などを確認し、どのような種類の情報が扱われているかを把握する。
    *   [ ] **Delta Pro 3の機能仕様調査:**
        *   入手可能なドキュメント、API情報、ユーザーマニュアル、レビュー記事などから、Delta Pro 3が提供する機能（監視項目、操作可能な設定）を洗い出す。
        *   特にバッテリー関連（SOC、電圧、電流、温度、SOH、サイクル数、充放電残時間、BMSエラー）、インバータ/出力関連（AC/DC出力電力・電圧・周波数、X-Boost）、入力関連（AC入力、ソーラー入力、カーチャージ）、デバイス全体設定（動作モード、EPS、ファン、LED、FWバージョン、SN）に注目する。
    *   [ ] **センサー項目の洗い出しと定義:**
        *   例: バッテリーSOC、入力電力合計、ソーラー入力（各MPPT）、AC出力電力、エラーコード、デバイス温度など。
        *   各センサーの単位、精度、更新頻度などを検討する。
    *   [ ] **スイッチ項目の洗い出しと定義:**
        *   例: AC出力ON/OFF、DC出力ON/OFF、X-Boost ON/OFF、ビープ音ON/OFFなど。
    *   [ ] **数値入力（スライダー等）項目の洗い出しと定義:**
        *   例: 充電上限SOC、放電下限SOC、AC充電電流設定など。
        *   各項目の最小値、最大値、ステップサイズを検討する。
    *   [ ] **セレクト（選択肢）項目の洗い出しと定義:**
        *   例: 動作モード選択（標準、静音など）、ソーラー充電優先度設定など。
    *   [ ] **各エンティティとProtobufメッセージフィールドの対応付け検討（初期段階）:**
        *   洗い出した各エンティティが、どのProtobufメッセージのどのフィールドに対応しそうか、大まかに見当をつける。（詳細はProtobuf設計タスクで深掘り）
    *   [ ] **ドキュメント化:** 洗い出したエンティティの一覧、各エンティティの仕様（名称、種類、単位、説明など）をまとめる。

## 2. Protobufデコード処理設計

*   **目的:** Delta Pro 3とクラウド間で送受信されるProtobufメッセージの構造を定義し、デコード処理のロジックを設計する。
*   **サブタスク:**
    *   [ ] **DP3通信仕様の再確認とProtobuf利用確定:**
        *   「DP3 Protobuf調査タスク」の成果物に基づき、DP3が実際にProtobufを使用しているか、その詳細仕様（トピック、メッセージ構造のヒント等）を確認する。
        *   もしProtobuf以外の形式（例: JSON）で主要データがやり取りされている場合は、このタスクの進め方を再検討する。
    *   [ ] **既存Protobuf定義 (`ecopacket.proto`, `platform.proto`) の流用可能性評価:**
        *   共通ヘッダー (`ecopacket.proto`) はDP3でも利用できるか？
        *   プラットフォーム共通機能 (`platform.proto`) のメッセージ型（`EnergyItem`, `EventRecordItem` 等）やコマンドIDはDP3に適用可能か、拡張が必要か？
    *   [ ] **DP3専用Protobufメッセージ定義の作成/検討 (`delta_pro_3.proto` 等):**
        *   DP3固有の状態情報（詳細なバッテリー情報、インバータ情報、専用設定項目など）を格納するための新しいメッセージ型を定義する必要があるか検討する。
        *   必要な場合、メッセージ名、フィールド名、データ型（`int32`, `string`, `bool`, `enum` など）、フィールド番号を設計する。
        *   エラーコードや警告コードの列挙型定義を検討する。
    *   [ ] **コマンド送受信のためのProtobufメッセージ設計:**
        *   デバイス設定変更（充電上限変更、出力ON/OFFなど）のためのリクエストメッセージと、それに対するレスポンスメッセージの形式を設計する。
        *   既存の `platform.proto` の `PlCmdId` を拡張するか、DP3専用のコマンドIDセットを定義するか検討する。
    *   [ ] **`.proto` ファイルの作成または更新:**
        *   決定したメッセージ定義に基づき、新規 `.proto` ファイルを作成するか、既存ファイルを修正する。
        *   `protoc` によるPythonコード生成手順を確認・実行する。
    *   [ ] **デコード処理フロー設計:**
        *   受信したバイト列をまず `ecopacket_pb2.SendHeaderMsg` でパースし、共通ヘッダー情報（コマンドID、製品ID等）を取得する。
        *   コマンドIDや製品IDに基づき、ペイロード部分をどのDP3用Protobufメッセージ（例: `DeltaPro3Heartbeat`, `DeltaPro3SettingsResponse`）でパースするかを決定するロジックを設計する。
        *   `ParseFromString()` を使用した具体的なデコード手順を明確にする。
        *   フィールドの存在確認 (`HasField()`) やデフォルト値の扱いを検討する。
    *   [ ] **エラーハンドリング設計:**
        *   パースエラー時の処理、未知のコマンドID受信時の処理などを定義する。
    *   [ ] **バージョニング対応の検討:**
        *   Protobufメッセージのバージョン管理が必要か、必要な場合はどのように対応するか（ヘッダー内のバージョンフィールド利用など）を検討する。
    *   [ ] **ドキュメント化:** 作成/更新した `.proto` ファイル、デコード処理フロー、エラーハンドリング方針などをまとめる。

## 3. デバイス判定・分岐ロジック設計

*   **目的:** 受信データやデバイス情報に基づき、処理対象がDelta Pro 3であるかを判定し、適切な処理ロジックへ分岐させる仕組みを設計する。
*   **サブタスク:**
    *   [ ] **既存デバイス（PowerStream等）の判定ロジック調査:**
        *   現在のコードで、どのようにデバイスの種類を特定し、処理を分けているかを確認する。（例: `product_type` フィールド、デバイスIDのプレフィックスなど）
    *   [ ] **Delta Pro 3を識別するためのキー情報の特定:**
        *   `ecopacket.Header` 内の `product_type` や `device_sn` の一部など、DP3を他のEcoFlow製品と区別できる一意な情報を特定する。
        *   MQTTトピック名からデバイスタイプを判別できる場合は、その情報も利用する。
    *   [ ] **デバイスクラスの構造設計:**
        *   `PowerStream` クラスのように、`DeltaPro3` デバイスクラスを作成することを検討する。
        *   共通のベースクラス（例: `EcoFlowAbstractEntity`）を継承し、デバイス固有の処理を `DeltaPro3` クラスに実装する構成を検討する。
    *   [ ] **デバイス判定ロジックの実装箇所検討:**
        *   データ受信時 (`_MQTTMessage.data_parse` や `EcoFlowAbstractEntity._prepare_data`) のどの段階でデバイス判定を行うのが適切か検討する。
    *   [ ] **分岐ロジックの設計:**
        *   判定結果に基づき、`DeltaPro3` クラスのメソッド（例: `_parse_heartbeat`, `_parse_settings`）が呼び出されるように処理を分岐させるロジックを設計する。
        *   新しいデバイスタイプが追加された際の拡張性を考慮する。
    *   [ ] **ドキュメント化:** デバイス判定に使用するキー情報、判定ロジック、クラス構造の概要などをまとめる。